import base64
import datetime
import hashlib
import logging
import os

from django.db import transaction, IntegrityError
from django.contrib.auth.models import User

from piston.handler import AnonymousBaseHandler

from api.exceptions import *
from traces.models import *
from mcuser.models import *
from modechoice.env_settings import API_SECRET_KEY

class AnonymousTraceDataHandler(AnonymousBaseHandler):
    """
    Accept trace data in bulk and add to the database.
    """
    allowed_methods = ('POST',)

    @transaction.commit_manually
    def create(self, request):
        attrs = self.flatten_dict(request.POST)
        loc_columns = ['lat', 'lon', 'gps_time', 'sample_time', 'velocity',
                    'haccuracy', 'altitude', 'course', 'service_provider',
                    'travel_mode', 'gps_sample_period', 'battery_level',]
        decimal_values = ['lat', 'lon', 'velocity', 'haccuracy', 'altitude',
                            'course',]

        android_columns = ['sample_time', 'lat', 'lon', 'data',]

        resp = {}
        valid_data = True
        is_android_data = False

        try:                
            if not (attrs.has_key('key')  and attrs.has_key('trace_data')
                    and attrs.has_key('username') and attrs.has_key('identifier')):
                logging.info(attrs)
                raise Exception("Key, username, identifier or trace data is missing")

            #log received data
            logging.debug("Location data received [username: %s] [identifier: %s]" %
                            (attrs.get('username'), attrs.get('identifier')))
            
            #We have the key, username, identifier and data
            username = attrs.get('username')
            identifier = attrs.get('identifier')
            trace_data_lines = attrs.get('trace_data').split("\n")
            if len(trace_data_lines) == 0:
                raise Exception("Trace data is missing")

            if attrs.has_key('state_machine_data'):
                is_android_data = True

            user = User.objects.get(username=username)

            #Check if this phone is active for the account
            try:
                user_meta_data = UserMetaData.objects.get(user=user,
                    phone_identifier=identifier)
            except UserMetaData.DoesNotExist:
                #Check if the phone is inactive
                try:
                    inactive_phone = UserInactivePhone.objects.get(user=user.id,
                        phone_identifier=identifier)
                        
                    #TODO: The phone making the request is no longer active, but
                    #it may still have data that we should save. Look for the
                    #last login time of the phone that is now active and add all
                    #the data collected earlier than that time from this request.
                    raise InactivePhoneException("This phone is no longer " +
                        "associated with the username %s" % (username))
                except UserInactivePhone.DoesNotExist:
                    #We should never encounter this exception. A phone should never
                    #upload data before the user has logged in at least once.
                    logging.critical("Received data from phone, but meta data is" +
                            " not available [username: %s] [identifier: %s]" %
                            (username, identifier))
                    raise Exception("Invalid request - could not find meta data")

            md5_key = hashlib.md5(API_SECRET_KEY + user.username).hexdigest()
            if attrs.get('key') != md5_key:
                raise Exception("Key is invalid")

            # Save details of this API access
            api_access = ApiAccessEvent(user=user, access_type=ApiAccessEvent.DATA_UPLOAD)
            api_access.save()

            columns = loc_columns if is_android_data == False else android_columns
            for key, sample in enumerate(trace_data_lines):
                fields = {"user" : user}
                parts = sample.split(",")

                if len(parts) < len(columns):
                        raise Exception("Mandatory values are missing")

                for index, part in enumerate(parts):
                    if part.strip() == "":
                            raise Exception("Mandatory values are missing")
                
                    if is_android_data == False: fields[loc_columns[index]] = part
                    else: fields[android_columns[index]] = part

                #Validate the numbers in this trace
                for key, part in fields.items():
                    if type(part) is float:
                        fields[key] = '%.6f' % part

                    #Check if any float value is out of bounds
                    if key in decimal_values and (float(part) > 999999 or float(part) < -999999):
                        valid_data = False
                        logging.warn("Out of bounds data received [android data: %s] [data: %s] " % \
                            (is_android_data, sample) )
                        break

                #Save this object
                if valid_data is True:
                    if is_android_data == False: data_obj = Data(**fields)
                    else: data_obj = AndroidData(**fields)

                    data_obj.save()             

            #Fetch and add the hotspot data if it is available
            hotspots = Hotspot.objects.filter(user=user)
            if len(hotspots) > 0:
                h_list = list()
                for h in hotspots:
                    h_list.append("%s,%s" % (h.lat,h.lon))

                resp.update({'hot_spots': ";".join(h_list)})

            resp.update({'code' : 1, 'message' : 'Success',
                        'sleep_time': user_meta_data.sleep_time})
        
        except InactivePhoneException as ip:
            transaction.rollback()
            logging.info("Phone is no longer associated with account " +
                "[username: %s] [identifier: %s]" % (username, identifier))
            resp.update({'code' : 2, 'message' : str(ip)})
        except Exception as ex:
            transaction.rollback()
            logging.exception( str(ex) )
            resp.update({'code' : 0, 'message' : str(ex)})
        else:
            transaction.commit()
            logging.debug("Wrote location data to the database [username: %s] [rows: %d] [android data: %s]" %
                (username, len(trace_data_lines), is_android_data))

        return resp

class AnonymousAuthHandler(AnonymousBaseHandler):
    """
    Accept a username and password and check if they are valid.
    I'm abusing Piston here... there's probably a better way to do this.
    """
    allowed_methods = ('POST',)

    @transaction.commit_manually
    def create(self, request):
        attrs = self.flatten_dict(request.POST)

        try:                
            if not (attrs.has_key('username') and attrs.has_key('password')
                and attrs.has_key('key') and attrs.has_key('identifier')
                and attrs.has_key('platform')):
                #logging.info(attrs)
                raise Exception("Username or password is missing")

            username = attrs.get('username')
            identifier = attrs.get('identifier')
            platform = attrs.get('platform')

            #TODO: Check if we need an index on the username column
            u = User.objects.get(username__exact=username)

            md5_key = hashlib.md5(API_SECRET_KEY + u.username).hexdigest()
            if attrs.get('key') != md5_key:
                raise Exception("Key is invalid")

            if not u.check_password(attrs.get('password')):
                raise Exception("Password is incorrect")

            #Check if this phone is active for the account
            try:
                user_meta_data = UserMetaData.objects.get(user=u)
		
		logging.debug("[username: %s] [active UDID: %s] [current UDID: %s]" %
                    (u.username, user_meta_data.phone_identifier, identifier))
                if user_meta_data.phone_identifier != identifier:
                    #The user is logging in on a different phone
                    if attrs.has_key('change_phone'):
                        inactive_phone = UserInactivePhone(user=u.id,
                                            phone_identifier=user_meta_data.phone_identifier,
                                            phone_platform=user_meta_data.phone_platform,)
                        inactive_phone.save()

                        user_meta_data.phone_identifier = identifier
                        user_meta_data.phone_platform = platform
                        user_meta_data.save()
                    else:
                        raise NewPhoneException("Your account is associated with a different phone." +
                            " Would you like to associate it with this phone instead?")
                else:
                    #This is just a routine login. The user had probably killed the application.
		    logging.debug("Routine login by [username: %s] [identifier: %s]" % (u.username, identifier))
                    user_meta_data.last_login = datetime.datetime.now()
                    user_meta_data.save()
            except UserMetaData.DoesNotExist:
                #The user is logging in for the first time.
                logging.debug("First login by [username: %s] [identifier: %s]" % (u.username, identifier))
                #TODO: Handle the case where the generated keys already exist
                secret_key = base64.urlsafe_b64encode(os.urandom(32))
                invite_code = base64.urlsafe_b64encode(os.urandom(6))
                user_meta_data = UserMetaData(user=u, secret_key=secret_key,
                    phone_identifier=identifier, phone_platform=platform,
                    invite_code=invite_code, last_login=datetime.datetime.now())
                try:
                    user_meta_data.save()
                except IntegrityError:
                    pass

            logging.info("User logged in [username: %s] [user id: %d]" %
                (u.username, u.id))
            resp = {'code' : 1, 'userid' : u.id, 'secret_key': user_meta_data.secret_key,
                    'email' : u.email, 'first_name' : u.first_name,
                    'last_name' : u.last_name}
        except User.DoesNotExist as e:
            transaction.rollback()
            logging.info("[username: " + username + "] [error: " + str(e) + "]")
            resp = {'code' : 0, 'message' : "The username is not valid."}
        except NewPhoneException as np:
            transaction.rollback()
            logging.info("[username: " + username + "] [error: " + str(np) + "]")
            resp = {'code' : 2, 'message' : str(np)}
        except Exception as ex:
            transaction.rollback()
            logging.exception( str(ex) )
            logging.info("[username: " + username + "] [error: " + str(ex) + "]")
            resp = {'code' : 0, 'message' : str(ex)}
        else:
            transaction.commit()

        return resp

class AnonymousLifecycleHandler(AnonymousBaseHandler):
    """
    Accept application lifecycle data and store in database.
    """
    allowed_methods = ('POST',)

    MANDATORY_VALUES = 2

    @transaction.commit_manually
    def create(self, request):
        attrs = self.flatten_dict(request.POST)
        columns = ['event_type', 'event_time', 'lat', 'lon', 'accuracy', 'last_fix_time']
        decimal_values = ['lat', 'lon',]

        try:
            if not (attrs.has_key('key') and attrs.has_key('event_data') and
                         attrs.has_key('username')):
                logging.info(attrs)
                raise Exception("Key, username or event data is missing")

            #log received data
            logging.debug("[key: %s] [username: %s] [event data: %s]"
                % (attrs.get('key'), attrs.get('username'),
                    attrs.get('event_data')))

            #We have the key, username and sensor data
            username = attrs.get('username')
            event_data_lines = attrs.get('event_data').split("\n")
            if len(event_data_lines) == 0:
                raise Exception("Event data is missing")

            user = User.objects.get(username=username)

            md5_key = hashlib.md5(API_SECRET_KEY + user.username).hexdigest()
            if attrs.get('key') != md5_key:
                raise Exception("Key is invalid")

            for key, sample in enumerate(event_data_lines):
                fields = {"user" : user}
                parts = sample.split(",")

                if len(parts) < self.MANDATORY_VALUES:
                    raise Exception("Mandatory values are missing")

                for index, part in enumerate(parts):
                    if part.strip() == "":
                            raise Exception("Blank strings are not allowed.")

                    fields[columns[index]] = part

                #Validate the numbers in this trace
                valid_data = True
                for key, part in fields.items():
                    if type(part) is float:
                        fields[key] = '%.6f' % part

                    #Check if any float value is out of bounds
                    if key in decimal_values and (float(part) > 999999 or float(part) < -999999):
                        valid_data = False
                        logging.warn("Out of bounds event data received [%s]" % sample)
                        break

                #Save this object
                if valid_data is True:
                    try:
                        event_obj = LifecycleEvent.objects.get(user=user,
                                        event_type=fields['event_type'],
                                        event_time=fields['event_time'],)
                        logging.debug("Did not write duplicate lifecycle event " + 
                            "to database [user: %s] [type: %s] [time: %s]" %
                            (user.username, fields['event_type'], fields['event_time']))
                    except LifecycleEvent.DoesNotExist:
                        event_obj = LifecycleEvent(**fields)
                        event_obj.save()
                    
            resp = {'code' : 1, 'message' : 'Success'}

        except Exception as ex:
            transaction.rollback()
            logging.exception( str(ex) )
            resp = {'code' : 0, 'message' : str(ex)}
        else:
            transaction.commit()

        return resp